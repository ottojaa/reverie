
# Plan 04 — Job Queue and Worker Architecture

## Goal
Set up a robust async job processing system to handle:
- OCR processing
- Thumbnail generation
- LLM summarization
- Batch operations

This keeps the API responsive and allows expensive operations to run in the background.

---

## Core Principles
- API never blocks on expensive operations
- Jobs are retryable and idempotent
- Clear job status tracking
- Workers can scale independently
- Jobs can be prioritized

---

## Technology Stack
- Job Queue: **BullMQ** (Redis-based)
- Message Broker: **Redis** (job queue + pub/sub for events)
- Workers: Separate Node.js processes
- Real-Time Updates: **Socket.io** (WebSockets)
- Job Types: OCR, Thumbnail, LLM Summary, Bulk Upload

---

## Architecture

### Job Queue (BullMQ + Redis)
- Redis connection configured via environment
- Separate queues for different job types:
  - `ocr-queue`: OCR processing
  - `thumbnail-queue`: Thumbnail generation
  - `llm-queue`: LLM summarization
- Each queue has configurable concurrency

### Worker Processes
Workers are separate Node.js processes that:
- Poll job queues
- Process jobs
- Update job status in `processing_jobs` table
- Retry on failure (with exponential backoff)

---

## Folder Structure

```
backend/
  src/
    queues/
      queue.config.ts
      ocr.queue.ts
      thumbnail.queue.ts
      llm.queue.ts

    workers/
      ocr.worker.ts
      thumbnail.worker.ts
      llm.worker.ts
      worker.utils.ts       // Includes Redis pub/sub for events

    jobs/
      job.types.ts
      job.service.ts        // CRUD for processing_jobs table

    websocket/
      socket.server.ts      // WebSocket server setup
      event-handlers.ts     // Socket event handlers
      redis-subscriber.ts   // Subscribe to Redis, forward to clients

    routes/
      jobs.route.ts         // Job status API endpoints
```

---

## Job Lifecycle

1. **Creation**: API endpoint creates job in `processing_jobs` table
2. **Enqueue**: Job is pushed to appropriate BullMQ queue
3. **Processing**: Worker picks up job, updates status to `processing`
4. **Completion**: Worker updates status to `complete`, stores result
5. **Failure**: Worker updates status to `failed`, increments attempts, retries

### Job Status States
- `pending`: Created, not yet picked up
- `processing`: Currently being worked on
- `complete`: Successfully finished
- `failed`: All retry attempts exhausted

---

## Job Types

### OCR Job
```typescript
{
  job_type: 'ocr',
  target_type: 'document',
  target_id: 'uuid',
  // Result stored in processing_jobs.result:
  result: {
    raw_text: string,
    confidence: number,
    metadata: {...}
  }
}
```

### Thumbnail Job
```typescript
{
  job_type: 'thumbnail',
  target_type: 'document',
  target_id: 'uuid',
  // Result:
  result: {
    blurhash: string,  // ~30 char blurhash for instant placeholder
    paths: {
      sm: string,      // 150px width
      md: string,      // 300px width  
      lg: string       // 600px width
    },
    original_dimensions: {
      width: number,
      height: number
    }
  }
}
```

**Thumbnail Generation Details:**
- Uses **sharp** for image resizing (maintains aspect ratio)
- Generates WebP format for smaller file sizes
- Uses **blurhash** library for placeholder hash generation
- Blurhash computed from smallest thumbnail (150px) for speed
- All sizes generated in parallel

### LLM Processing Job
```typescript
{
  job_type: 'llm_summary',
  target_type: 'document',
  target_id: 'uuid',
  // Result:
  result: {
    summary: string,
    enhanced_metadata: {
      title: string,
      key_entities: string[],
      topics: string[],
      ...
    },
    token_count: number
  }
}
```

---

## Configuration

Environment variables:
```
REDIS_URL=redis://localhost:6379
JOB_CONCURRENCY_OCR=2
JOB_CONCURRENCY_THUMBNAIL=4
JOB_CONCURRENCY_LLM=1
JOB_RETRY_ATTEMPTS=3
JOB_RETRY_BACKOFF_MS=5000

# WebSocket configuration
WS_CORS_ORIGIN=http://localhost:8081,http://localhost:19006  # Expo dev servers
WS_ENABLED=true
```

---

## Worker Startup

Workers can run:
- **Alongside API** (single process, all workers): Development mode
- **Separate processes**: Production mode for scaling

Scripts:
- `npm run worker:ocr`: Start OCR worker
- `npm run worker:thumbnail`: Start thumbnail worker
- `npm run worker:llm`: Start LLM worker
- `npm run worker:all`: Start all workers

---

## Monitoring and Observability

### Job Dashboard (Optional)
- BullMQ provides Bull Board for web UI
- Shows queue status, failed jobs, retry counts
- Mount at `/admin/jobs` (auth required)

### Logging
- Log job start, completion, failures
- Include job ID, duration, result summary
- Error logs include full stack trace

---

## Error Handling

### Retryable Errors
- Network failures (OpenAI API timeout)
- Temporary storage issues
- Database connection errors

### Non-Retryable Errors
- Invalid file format
- Missing document in storage
- Invalid job configuration

Workers differentiate and mark jobs as `failed` immediately for non-retryable errors.

---

## Real-Time Progress Tracking (WebSockets)

### Architecture
WebSockets provide instant feedback to clients about job progress without polling.

**Flow:**
1. Worker completes job → publishes event to Redis pub/sub
2. API server subscribes to Redis events → forwards to WebSocket clients
3. Client receives instant update → updates UI

### Redis Pub/Sub Setup

**Publisher (Workers):**
```typescript
// workers/worker.utils.ts
import { Redis } from 'ioredis'

const redisPublisher = new Redis(process.env.REDIS_URL)

export async function publishJobEvent(event: JobEvent) {
  await redisPublisher.publish('job:events', JSON.stringify(event))
}

export interface JobEvent {
  type: 'job:started' | 'job:progress' | 'job:complete' | 'job:failed'
  job_id: string
  document_id?: string
  folder_id?: string
  status: JobStatus
  progress?: number  // 0-100
  error_message?: string
  result?: any
}
```

**Usage in Worker:**
```typescript
// workers/ocr.worker.ts
async function processOcrJob(job: Job<OcrJobData>) {
  // Notify start
  await publishJobEvent({
    type: 'job:started',
    job_id: job.id,
    document_id: job.data.documentId,
    status: 'processing',
    progress: 0
  })
  
  // Process...
  const result = await ocrService.processDocument(job.data.documentId)
  
  // Notify complete
  await publishJobEvent({
    type: 'job:complete',
    job_id: job.id,
    document_id: job.data.documentId,
    status: 'complete',
    progress: 100,
    result
  })
}
```

### WebSocket Server Setup

**Server (Fastify + Socket.io):**
```typescript
// server.ts
import fastify from 'fastify'
import fastifySocketIO from 'fastify-socket.io'
import { Redis } from 'ioredis'

const app = fastify()

// Register Socket.io
await app.register(fastifySocketIO, {
  cors: { origin: '*' }  // Configure properly in production
})

// Subscribe to Redis events
const redisSubscriber = new Redis(process.env.REDIS_URL)
await redisSubscriber.subscribe('job:events')

// Forward Redis events to WebSocket clients
redisSubscriber.on('message', (channel, message) => {
  const event: JobEvent = JSON.parse(message)
  
  // Broadcast to all clients (or use rooms for targeted delivery)
  app.io.emit(event.type, event)
  
  // Or send to specific session room:
  if (event.session_id) {
    app.io.to(`session:${event.session_id}`).emit(event.type, event)
  }
})
```

### Client Integration

**Connect and Subscribe:**
```typescript
// client/services/websocket.service.ts
import io from 'socket.io-client'

const socket = io('http://localhost:3000')

socket.on('connect', () => {
  console.log('Connected to server')
})

socket.on('job:started', (event: JobEvent) => {
  updateJobStatus(event.job_id, 'processing', event.progress)
})

socket.on('job:complete', (event: JobEvent) => {
  updateJobStatus(event.job_id, 'complete', 100)
  showNotification(`${event.document_id} processed successfully`)
})

socket.on('job:failed', (event: JobEvent) => {
  updateJobStatus(event.job_id, 'failed', 0)
  showError(event.error_message)
})
```

**React Native Usage:**
```typescript
// client/screens/UploadScreen.tsx
const [uploadProgress, setUploadProgress] = useState<UploadProgress>({
  total: 0,
  completed: 0,
  processing: 0,
  failed: 0,
  documents: []
})

useEffect(() => {
  const socket = connectWebSocket()
  
  socket.on('job:complete', (event) => {
    setUploadProgress(prev => ({
      ...prev,
      completed: prev.completed + 1,
      processing: prev.processing - 1,
      documents: prev.documents.map(doc => 
        doc.id === event.document_id 
          ? { ...doc, status: 'complete' }
          : doc
      )
    }))
  })
  
  return () => socket.disconnect()
}, [])
```

### Upload Session Tracking

For batch uploads, group jobs into a session:

**Backend:**
```typescript
POST /api/upload
{
  files: [...],
  folder_id: 'folder-123'
}

Response:
{
  session_id: 'upload-session-abc123',
  documents: [...],
  jobs: [...]
}
```

**Client subscribes to session:**
```typescript
socket.emit('subscribe:session', { session_id: 'upload-session-abc123' })

// Only receive events for jobs in this session
socket.on('job:complete', (event) => {
  if (event.session_id === currentSessionId) {
    // Handle update
  }
})
```

### Progress API Endpoints (Fallback)

For clients that can't use WebSockets (or as fallback):

```typescript
// Get status of multiple jobs
GET /api/jobs/batch?ids=job-1,job-2,job-3
Response: [
  { id: 'job-1', status: 'complete', progress: 100 },
  { id: 'job-2', status: 'processing', progress: 45 },
  { id: 'job-3', status: 'pending', progress: 0 }
]

// Get document processing status
GET /api/documents/:id/status
Response: {
  document_id: 'doc-1',
  ocr_status: 'complete',
  thumbnail_status: 'processing',
  jobs: [
    { type: 'ocr', status: 'complete', completed_at: '...' },
    { type: 'thumbnail', status: 'processing', progress: 60 }
  ]
}

// Get all jobs for an upload session
GET /api/upload-sessions/:sessionId
Response: {
  session_id: 'upload-session-abc123',
  total_jobs: 10,
  completed: 7,
  processing: 2,
  failed: 1,
  jobs: [...]
}
```

### UI Progress Components

**Upload Progress Card:**
```tsx
<View>
  <Text>Uploading {total} documents...</Text>
  <ProgressBar progress={completed / total} />
  <Text>{completed}/{total} complete</Text>
  
  {documents.map(doc => (
    <DocumentProgressItem key={doc.id} document={doc} />
  ))}
</View>
```

**Document Progress Item:**
```tsx
function DocumentProgressItem({ document }) {
  return (
    <View>
      <Text>{document.filename}</Text>
      {document.status === 'complete' && <Icon name="check" color="green" />}
      {document.status === 'processing' && <Spinner />}
      {document.status === 'failed' && <Icon name="error" color="red" />}
    </View>
  )
}
```

---

## Integration with Services

### Upload Flow Example (with WebSocket Updates)
1. **Client** uploads images via `/api/upload`
2. **Upload service**:
   - Stores files via storage provider
   - Creates documents in DB
   - Creates OCR jobs in `processing_jobs`
   - Enqueues OCR jobs in BullMQ
   - Returns immediately: `{ session_id: 'xyz', documents: [...], jobs: [...] }`
3. **Client** subscribes to WebSocket session updates
4. **OCR worker**:
   - Picks up job
   - Publishes `job:started` event to Redis
   - Processes image
   - Stores result in `ocr_results`
   - Updates `documents.ocr_status = 'complete'`
   - Publishes `job:complete` event to Redis
5. **WebSocket server** receives Redis event, forwards to client
6. **Client** receives instant update, updates UI (no polling needed)

---

## Acceptance Criteria
- Redis connection established
- BullMQ queues configured
- At least one worker (OCR) can process jobs
- Jobs are created in `processing_jobs` table
- Job status updates are persisted
- Failed jobs retry with backoff
- Worker can run independently from API process
- WebSocket server configured and running
- Workers publish job events to Redis pub/sub
- API server forwards Redis events to WebSocket clients
- Client can subscribe to real-time job updates
- Fallback REST API endpoints for job status work without WebSockets

---

## Future Enhancements
- Dead letter queue for permanently failed jobs
- Job priority system (user-triggered vs batch)
- Scheduled jobs (periodic maintenance tasks, batch reprocessing)
- Job progress percentage for long-running tasks (OCR with large images)
- Bulk job operations (pause/resume/cancel multiple jobs)
- Job history and analytics (average processing time, failure rates)
- Email notifications for completed batch uploads


