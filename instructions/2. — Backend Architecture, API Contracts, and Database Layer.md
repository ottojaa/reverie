
# Plan 02 — Backend Architecture, API Contracts, and Database Layer

## Goal
Establish a type-safe, modern backend foundation with:
- Fastify for the HTTP API
- Zod for validation and schemas
- PostgreSQL as the database
- Kysely for type-safe SQL
- Shared API contracts usable by both backend and client
- Optional OpenAPI generation

No business features are implemented yet. This phase is architecture and scaffolding only.

---

## Core Principles
- API contracts are defined once and shared
- Runtime validation equals compile-time types
- Database schema is explicit and type-safe
- API layer, domain logic, and persistence are clearly separated
- Everything works cleanly inside an Nx monorepo

---

## Technology Stack
- Runtime: Node.js
- Framework: Fastify
- Validation & schemas: Zod
- Database: PostgreSQL
- Query builder: Kysely
- API contracts: Shared Zod schemas
- OpenAPI: Generated from Zod schemas (optional but wired)

---

## Folder Structure

backend/
  src/
    main.ts
    app.ts
    server.ts

    config/
      env.ts
      db.ts

    db/
      kysely.ts
      schema.ts
      migrations/

    routes/
      health.route.ts
      upload.route.ts

    services/
      upload.service.ts
      storage.service.ts

    storage/
      storage.interface.ts
      local-storage.ts
      s3-storage.ts

    plugins/
      zod.ts
      openapi.ts

shared/
  src/
    api/
      schemas/
        common.ts
        upload.ts
        jobs.ts           // Job status schemas
      contracts.ts

    domain/
      document.ts
      folder.ts

    events/
      job-events.ts       // WebSocket event types

    errors.ts

---

## Database Layer (PostgreSQL + Kysely)

### Kysely Setup
- Define a `Database` TypeScript interface describing all tables
- Each table explicitly defines:
  - Column names
  - Types
  - Nullable vs non-nullable fields

Initial tables:
- **folders**: Organizational structure (user-written descriptions)
- **documents**: Core document metadata (includes LLM results)
- **ocr_results**: OCR text and extracted metadata
- **processing_jobs**: Async job tracking (OCR, LLM, thumbnails)
- **document_tags**: User-defined and auto-generated tags

### Core Tables Schema

```typescript
folders:
  - id (uuid, pk)
  - parent_id (uuid, fk to folders, nullable)
  - name (text)
  - path (text, unique) // full hierarchical path
  - description (text, nullable) // user-written description
  - created_at (timestamp)
  - updated_at (timestamp)

documents:
  - id (uuid, pk)
  - folder_id (uuid, fk to folders)
  - file_path (text) // storage path (abstracted)
  - file_hash (text, indexed) // SHA-256 for dedup
  - original_filename (text)
  - mime_type (text)
  - size_bytes (bigint)
  - width (int, nullable) // image dimensions
  - height (int, nullable)
  - thumbnail_blurhash (text, nullable) // ~30 char blurhash string
  - thumbnail_paths (jsonb, nullable) // {"sm": "path/150.jpg", "md": "path/300.jpg", "lg": "path/600.jpg"}
  - document_category (text, nullable) // auto-classified or user-set
  - extracted_date (date, nullable) // date mentioned in document
  - ocr_status (enum: pending, processing, complete, failed)
  - thumbnail_status (enum: pending, processing, complete, failed)
  - llm_summary (text, nullable) // LLM-generated summary
  - llm_metadata (jsonb, nullable) // enhanced metadata from LLM
  - llm_processed_at (timestamp, nullable)
  - llm_token_count (int, nullable)
  - created_at (timestamp)
  - updated_at (timestamp)

ocr_results:
  - id (uuid, pk)
  - document_id (uuid, fk to documents, unique)
  - raw_text (text) // full OCR output
  - confidence_score (float, nullable)
  - metadata (jsonb) // structured extraction: {company, values, dates, etc}
  - text_vector (tsvector) // for full-text search
  - processed_at (timestamp)

processing_jobs:
  - id (uuid, pk)
  - job_type (enum: ocr, thumbnail, llm_summary)
  - target_type (enum: document, folder)
  - target_id (uuid)
  - status (enum: pending, processing, complete, failed)
  - priority (int, default 0)
  - attempts (int, default 0)
  - error_message (text, nullable)
  - result (jsonb, nullable)
  - created_at (timestamp)
  - started_at (timestamp, nullable)
  - completed_at (timestamp, nullable)

document_tags:
  - id (uuid, pk)
  - document_id (uuid, fk to documents)
  - tag (text)
  - source (enum: user, auto) // user-added vs auto-extracted
  - created_at (timestamp)
  - unique(document_id, tag)
```

### Database Configuration
- PostgreSQL connection configured via environment variables
- Kysely instance created in `backend/src/db/kysely.ts`
- Export a typed `db` instance for use in services

### Migrations
- Use Kysely’s migration system
- Migration files live in `backend/src/db/migrations`
- Migrations are backend-only and never imported by shared code

---

## Storage Abstraction Layer

### Purpose
Abstract file storage to support multiple backends:
- Local filesystem (primary for self-hosted machine)
- S3-compatible storage (MinIO, AWS S3, etc)

### Interface Design
```typescript
interface IStorageProvider {
  store(file: Buffer, path: string, metadata?: StorageMetadata): Promise<StorageResult>
  retrieve(path: string): Promise<Buffer>
  delete(path: string): Promise<void>
  exists(path: string): Promise<boolean>
  getMetadata(path: string): Promise<StorageMetadata>
  generateUrl(path: string, expiresIn?: number): Promise<string> // for serving
}
```

### Implementations
- **LocalStorageProvider**: Stores files on disk, paths are relative to configured root
- **S3StorageProvider**: Stores files in S3-compatible bucket

### Configuration
Storage provider is selected via environment variable:
```
STORAGE_PROVIDER=local # or 's3'
STORAGE_LOCAL_ROOT=/path/to/files
STORAGE_S3_BUCKET=reverie
STORAGE_S3_ENDPOINT=...
STORAGE_S3_ACCESS_KEY=...
STORAGE_S3_SECRET_KEY=...
```

### Path Strategy
Files are stored using content-addressable paths:
```
/{hash[0:2]}/{hash[2:4]}/{hash}.{ext}
```
Example: `a1/b2/a1b2c3d4e5f6...jpg`

This ensures:
- Automatic deduplication
- Balanced directory structure
- No filename collisions

---

## Shared API Contracts

### Location
- All request and response schemas live in `shared/src/api/schemas`
- All schemas are exported via `shared/src/api/contracts.ts`

### Schema Rules
- Zod is used for:
  - Request bodies
  - Query parameters
  - API responses
- Each schema provides:
  - Runtime validation
  - Type inference via `z.infer`

Examples:
- UploadImagesRequestSchema
- UploadImagesResponseSchema
- ApiErrorSchema
- JobStatusSchema
- JobEventSchema (for WebSocket events)

### Example Shared Schemas
```typescript
// shared/src/api/schemas/jobs.ts
import { z } from 'zod'

export const JobStatusEnum = z.enum(['pending', 'processing', 'complete', 'failed'])
export const JobTypeEnum = z.enum(['ocr', 'thumbnail', 'llm_summary'])

export const JobSchema = z.object({
  id: z.string().uuid(),
  job_type: JobTypeEnum,
  status: JobStatusEnum,
  progress: z.number().min(0).max(100).optional(),
  error_message: z.string().optional(),
  created_at: z.string().datetime(),
  completed_at: z.string().datetime().optional(),
})

export type Job = z.infer<typeof JobSchema>
```

```typescript
// shared/src/events/job-events.ts
import { z } from 'zod'

export const JobEventTypeEnum = z.enum([
  'job:started',
  'job:progress', 
  'job:complete',
  'job:failed'
])

export const JobEventSchema = z.object({
  type: JobEventTypeEnum,
  job_id: z.string().uuid(),
  document_id: z.string().uuid().optional(),
  folder_id: z.string().uuid().optional(),
  session_id: z.string().optional(),
  status: z.enum(['pending', 'processing', 'complete', 'failed']),
  progress: z.number().min(0).max(100).optional(),
  error_message: z.string().optional(),
  result: z.any().optional(),
  timestamp: z.string().datetime(),
})

export type JobEvent = z.infer<typeof JobEventSchema>
```

Both backend and client import these types, ensuring type safety across the entire stack.

---

## Backend API Layer (Fastify)

### Route Definition
- Routes import schemas from the shared package
- Fastify uses Zod schemas for request validation
- Route handlers are thin and delegate to services

Request flow:
1. Fastify validates input using Zod schemas
2. Route handler calls a service function
3. Service performs database operations via Kysely
4. Response is validated against a Zod response schema

---

## Service Layer

- Services contain all business logic
- Services:
  - Perform database queries
  - Manage transactions
  - Prepare async jobs (later phases)
- Services do not depend on Fastify or HTTP concepts
- Services return domain-level objects or DTOs

---

## Error Handling

- A unified API error shape is defined in `shared/errors.ts`
- Zod validation errors are mapped to API errors
- Database errors are wrapped at the service boundary
- Routes never leak raw database errors

---

## OpenAPI (Optional but Enabled)

- Zod schemas are converted to OpenAPI definitions
- Swagger UI is exposed at `/docs`
- OpenAPI JSON is available for tooling
- OpenAPI generation does not affect runtime behavior

---

## Search Infrastructure (Basic Setup)

### Full-Text Search
- Use PostgreSQL's built-in full-text search capabilities
- `ocr_results.text_vector` column of type `tsvector`
- Automatically updated via trigger on `raw_text` changes
- Supports queries like: `SELECT * WHERE text_vector @@ to_tsquery('company & stock')`

### Indexing Strategy
```sql
CREATE INDEX idx_ocr_text_search ON ocr_results USING GIN(text_vector);
CREATE INDEX idx_documents_category ON documents(document_category);
CREATE INDEX idx_documents_extracted_date ON documents(extracted_date);
CREATE INDEX idx_documents_hash ON documents(file_hash);
CREATE INDEX idx_document_tags_tag ON document_tags(tag);
```

### Search Query Examples (to be implemented later)
- Search by content: "find documents containing 'Apple Inc'"
- Search by date range: "documents between 2022-2025"
- Search by category: "stock_overview documents"
- Combined: "Apple Inc stock_overview 2023-2024"

### Future Considerations
- Semantic search via embeddings (pgvector extension)
- Separate search service (Meilisearch/Typesense) if Postgres becomes bottleneck
- Faceted search UI

---

## Acceptance Criteria
- Backend boots successfully
- PostgreSQL connection is established
- Kysely migrations can be executed
- All tables created with proper indexes
- Storage abstraction layer is implemented (at least LocalStorageProvider)
- `/health` endpoint responds successfully
- API schemas are imported from the shared package
- Client code can import request/response types from shared
- Full-text search indexes are created on `ocr_results`

