# Plan 07 — Advanced Search Implementation

## Goal

Implement powerful search capabilities allowing users to find any uploaded content by:

- **Content**: OCR text, LLM summaries, descriptions
- **Metadata**: Filenames, tags, categories
- **Filters**: File type, format, dates, folders, size
- **Entities**: Companies, people, places (extracted by OCR/LLM)
- **Combinations** of the above

The search should handle both:
- **Generic queries**: "vacation photos from 2024", "large PDFs", "files in /receipts"
- **Content-specific queries**: "stock_overview documents containing 'Apple' from 2022-2025"

---

## Core Principles

- Fast queries (<100ms for most searches)
- Intuitive query syntax (simple text search works, power users can use filters)
- Fuzzy matching for typos
- Faceted filtering (filter-as-you-type)
- Search results include snippets/highlights
- **Works for all file types** — including photos without text (search by filename, folder, category, tags)

---

## Technology Stack

- Primary: **PostgreSQL full-text search** (built-in)
- Query parsing: Custom parser for search syntax
- Highlighting: `ts_headline` function
- Future: Semantic search via **pgvector** extension (embeddings)

---

## Search Query Syntax

### Basic Text Search

Simple text searches across all searchable fields (filename, OCR text, LLM summary, tags):

```
vacation beach
"Apple Inc"
error screenshot
```

### Scoped Text Search

Search within specific fields:

```
in:filename vacation          # Only search filenames
in:content Apple              # Only search OCR text/content
in:summary tax                # Only search LLM summaries
```

---

### Filter Reference

| Filter | Syntax | Examples |
|--------|--------|----------|
| **type** | `type:<category>` | `type:photo`, `type:document`, `type:receipt`, `type:screenshot` |
| **format** | `format:<ext>` | `format:pdf`, `format:jpg`, `format:png` |
| **category** | `category:<name>` | `category:receipt`, `category:stock_statement` |
| **uploaded** | `uploaded:<date>` | `uploaded:2024`, `uploaded:2024-01..2024-03`, `uploaded:last-week` |
| **date** | `date:<date>` | `date:2023`, `date:2022-2025` (extracted date from document content) |
| **folder** | `folder:<path>` | `folder:/vacation/2024`, `folder:receipts` |
| **tag** | `tag:<name>` | `tag:important`, `tag:tax` |
| **has** | `has:<property>` | `has:text`, `has:summary`, `has:thumbnail` |
| **size** | `size:<comparison>` | `size:>1MB`, `size:<100KB` |
| **entity** | `entity:<name>` | `entity:Apple`, `entity:"John Smith"` |
| **company** | `company:<name>` | `company:Apple`, `company:Microsoft` (alias for entity) |

---

### Filter Examples

**By file type:**
```
type:photo                    # All photos
type:document                 # All documents with text
type:screenshot               # All screenshots
```

**By file format:**
```
format:pdf                    # All PDFs
format:jpg format:png         # JPGs and PNGs
```

**By upload date (when you added the file):**
```
uploaded:2024                 # Uploaded in 2024
uploaded:last-week            # Uploaded in the last 7 days
uploaded:2024-01..2024-06     # Uploaded Jan-Jun 2024
```

**By extracted date (date mentioned in document content):**
```
date:2023                     # Document date is 2023
date:2022-2025                # Document date between 2022-2025
```

**By folder:**
```
folder:/vacation/2024         # Exact folder path
folder:vacation               # Any folder containing "vacation"
```

**By properties:**
```
has:text                      # Has OCR-extracted text
has:summary                   # Has LLM summary
-has:text                     # Does NOT have text (photos)
```

**By size:**
```
size:>10MB                    # Files larger than 10MB
size:<100KB                   # Files smaller than 100KB
```

**By entities (extracted by OCR/LLM):**
```
company:Apple                 # Documents mentioning Apple
entity:"John Smith"           # Documents mentioning a person
```

**By tags:**
```
tag:important                 # Has "important" tag
tag:tax tag:2023              # Has both tags
```

---

### Combined Queries

**Find vacation photos from 2024:**
```
type:photo folder:vacation uploaded:2024
```

**Find receipts over $100 from last month:**
```
type:receipt uploaded:last-month "$100" OR "$200" OR "$300"
```

**Find stock documents mentioning Apple from 2022-2025:** *(original use case)*
```
category:stock_statement company:Apple date:2022-2025
```

**Find all PDFs in the tax folder:**
```
format:pdf folder:/documents/tax
```

**Find large files without thumbnails:**
```
size:>5MB -has:thumbnail
```

**Find screenshots containing "error":**
```
type:screenshot error
```

---

## Search Architecture

### Query Parser

Converts user query into structured search object:

```typescript
interface ParsedQuery {
  // Text search
  fullText?: string;              // Free-text search terms
  searchScope?: 'all' | 'filename' | 'content' | 'summary';
  
  // File type filters
  types?: DocumentCategory[];     // photo, document, receipt, screenshot
  formats?: string[];             // pdf, jpg, png
  
  // Date filters
  uploadedRange?: DateRange;      // When file was uploaded
  extractedDateRange?: DateRange; // Date mentioned in document
  
  // Location filters
  folders?: string[];             // Folder paths or names
  
  // Property filters
  hasText?: boolean;
  hasSummary?: boolean;
  hasThumbnail?: boolean;
  
  // Size filter
  sizeMin?: number;               // Bytes
  sizeMax?: number;
  
  // Metadata filters
  categories?: string[];          // Document categories
  tags?: string[];
  entities?: string[];            // Extracted entities (companies, people, etc.)
  
  // Negations
  negations?: Partial<ParsedQuery>; // Filters prefixed with -
}

interface DateRange {
  start?: Date;
  end?: Date;
  relative?: 'today' | 'yesterday' | 'last-week' | 'last-month' | 'last-year';
}
```

### Kysely Query Builder

Generates efficient PostgreSQL queries using Kysely's type-safe query builder.

**Query:** `type:photo folder:vacation uploaded:2024`

```typescript
const results = await db
  .selectFrom('documents as d')
  .leftJoin('folders as f', 'f.id', 'd.folder_id')
  .select([
    'd.id',
    'd.original_filename',
    'd.document_category',
    'd.created_at as uploaded_at',
    'd.thumbnail_paths',
    'f.path as folder_path',
  ])
  .where('d.document_category', 'in', ['photo', 'screenshot', 'graphic'])
  .where('f.path', 'ilike', '%vacation%')
  .where('d.created_at', '>=', new Date('2024-01-01'))
  .where('d.created_at', '<=', new Date('2024-12-31'))
  .orderBy('d.created_at', 'desc')
  .limit(50)
  .execute();
```

**Query:** `category:stock_statement company:Apple date:2022-2025`

```typescript
import { sql } from 'kysely';

const searchTerm = 'Apple';
const tsQuery = sql`to_tsquery('english', ${searchTerm})`;

const results = await db
  .selectFrom('documents as d')
  .innerJoin('ocr_results as ocr', 'ocr.document_id', 'd.id')
  .select([
    'd.id',
    'd.original_filename',
    'd.extracted_date',
    'd.document_category',
    'ocr.raw_text',
    sql<string>`ts_headline('english', ocr.raw_text, ${tsQuery}, 'MaxWords=50, MinWords=25')`.as('snippet'),
    sql<number>`ts_rank(ocr.text_vector, ${tsQuery})`.as('relevance'),
  ])
  .where('d.document_category', '=', 'stock_statement')
  .where((eb) =>
    eb.or([
      sql<boolean>`ocr.metadata->'companies' ? ${searchTerm}`,
      sql<boolean>`ocr.text_vector @@ ${tsQuery}`,
    ])
  )
  .where('d.extracted_date', '>=', new Date('2022-01-01'))
  .where('d.extracted_date', '<=', new Date('2025-12-31'))
  .orderBy(sql`ts_rank(ocr.text_vector, ${tsQuery})`, 'desc')
  .orderBy('d.extracted_date', 'desc')
  .limit(50)
  .execute();
```

**Full-text search with dynamic filters:**

```typescript
function buildSearchQuery(parsed: ParsedQuery, options: SearchOptions) {
  let query = db
    .selectFrom('documents as d')
    .leftJoin('folders as f', 'f.id', 'd.folder_id')
    .leftJoin('ocr_results as ocr', 'ocr.document_id', 'd.id');

  // Add text search if provided
  if (parsed.fullText) {
    const tsQuery = sql`plainto_tsquery('english', ${parsed.fullText})`;
    query = query
      .select(sql<number>`ts_rank(ocr.text_vector, ${tsQuery})`.as('relevance'))
      .where(sql`ocr.text_vector @@ ${tsQuery}`);
  }

  // Add type filter
  if (parsed.types?.length) {
    query = query.where('d.document_category', 'in', parsed.types);
  }

  // Add format filter
  if (parsed.formats?.length) {
    query = query.where('d.mime_type', 'in', 
      parsed.formats.map(f => mimeTypeFromExtension(f))
    );
  }

  // Add uploaded date filter
  if (parsed.uploadedRange?.start) {
    query = query.where('d.created_at', '>=', parsed.uploadedRange.start);
  }
  if (parsed.uploadedRange?.end) {
    query = query.where('d.created_at', '<=', parsed.uploadedRange.end);
  }

  // Add folder filter
  if (parsed.folders?.length) {
    query = query.where((eb) =>
      eb.or(parsed.folders!.map(folder => 
        eb('f.path', 'ilike', `%${folder}%`)
      ))
    );
  }

  // Add has:text filter
  if (parsed.hasText === true) {
    query = query.where('d.has_meaningful_text', '=', true);
  } else if (parsed.hasText === false) {
    query = query.where('d.has_meaningful_text', '=', false);
  }

  // Add size filter
  if (parsed.sizeMin) {
    query = query.where('d.size_bytes', '>=', parsed.sizeMin);
  }
  if (parsed.sizeMax) {
    query = query.where('d.size_bytes', '<=', parsed.sizeMax);
  }

  // Add tag filter
  if (parsed.tags?.length) {
    query = query
      .innerJoin('document_tags as dt', 'dt.document_id', 'd.id')
      .where('dt.tag', 'in', parsed.tags);
  }

  // Add entity filter (searches in JSONB metadata)
  if (parsed.entities?.length) {
    query = query.where((eb) =>
      eb.or(parsed.entities!.map(entity =>
        sql<boolean>`ocr.metadata->'companies' ? ${entity}`
      ))
    );
  }

  return query
    .orderBy(parsed.fullText ? 'relevance' : 'd.created_at', 'desc')
    .limit(options.limit ?? 50)
    .offset(options.offset ?? 0);
}
```

---

## Folder Structure

```
backend/
  src/
    search/
      search.service.ts        // Main search orchestration
      query-parser.ts          // Parse user query syntax
      query-builder.ts         // Build SQL from ParsedQuery
      highlighter.ts           // Snippet generation
      facets.ts                // Generate filter counts

    routes/
      search.route.ts

shared/
  src/
    api/
      schemas/
        search.ts              // SearchRequestSchema, SearchResponseSchema
```

---

## Search Service Interface

```typescript
interface SearchService {
  search(query: string, options: SearchOptions): Promise<SearchResults>;
  getFacets(query: string): Promise<SearchFacets>;
  suggest(type: SuggestionType, prefix: string): Promise<string[]>;
}

type SuggestionType = 'filename' | 'tag' | 'folder' | 'entity' | 'category';

interface SearchOptions {
  limit?: number;
  offset?: number;
  sortBy?: 'relevance' | 'uploaded' | 'date' | 'filename' | 'size';
  sortOrder?: 'asc' | 'desc';
  includeFacets?: boolean;
}

interface SearchResults {
  total: number;
  results: SearchResult[];
  facets?: SearchFacets;
  query: ParsedQuery;
  timing_ms: number;
}

interface SearchResult {
  document_id: string;
  filename: string;
  folder_path: string;
  folder_id: string;
  
  // Dates
  uploaded_at: Date;
  extracted_date?: Date;
  
  // Classification
  category?: string;
  mime_type: string;
  format: string;              // File extension
  
  // Content
  snippet?: string;            // Highlighted excerpt (if text search)
  has_text: boolean;
  
  // Visual
  thumbnail_url?: string;
  blurhash?: string;
  
  // Metadata
  size_bytes: number;
  tags: string[];
  
  // Relevance (for text searches)
  relevance?: number;
}

interface SearchFacets {
  // Primary facets (always shown)
  types: FacetItem[];          // photo, document, receipt, screenshot
  formats: FacetItem[];        // pdf, jpg, png, etc.
  folders: FacetItem[];        // Top folders with counts
  uploadPeriod: FacetItem[];   // This week, this month, older
  
  // Secondary facets
  tags: FacetItem[];
  hasText: FacetItem[];        // With text / Without text
  
  // Entity facets (if entities extracted)
  entities?: FacetItem[];      // Companies, people, etc.
}

interface FacetItem {
  name: string;
  count: number;
  selected?: boolean;          // Currently filtered
}
```

---

## Query Examples

### Example 1: Simple Text Search

```
User input: "beach sunset"

Parsed:
{
  fullText: "beach sunset",
  searchScope: "all"
}

Searches: filenames, OCR text, LLM summaries, tags
```

### Example 2: Find All Photos

```
User input: type:photo

Parsed:
{
  types: ["photo"]
}

SQL WHERE:
d.document_category = 'photo'
```

### Example 3: Files Uploaded Recently

```
User input: uploaded:last-week

Parsed:
{
  uploadedRange: { relative: "last-week" }
}

SQL WHERE:
d.created_at >= NOW() - INTERVAL '7 days'
```

### Example 4: Search Within Folder

```
User input: folder:/vacation/2024 beach

Parsed:
{
  fullText: "beach",
  folders: ["/vacation/2024"]
}

SQL WHERE:
f.path = '/vacation/2024'
AND (
  d.original_filename ILIKE '%beach%'
  OR ocr.text_vector @@ to_tsquery('english', 'beach')
  OR d.llm_summary ILIKE '%beach%'
)
```

### Example 5: Financial Document Query (original use case)

```
User input: category:stock_statement company:Apple date:2022-2025

Parsed:
{
  categories: ["stock_statement"],
  entities: ["Apple"],
  extractedDateRange: { start: 2022-01-01, end: 2025-12-31 }
}

SQL WHERE:
d.document_category = 'stock_statement'
AND (ocr.metadata->'companies' ? 'Apple' OR ocr.text_vector @@ to_tsquery('english', 'Apple'))
AND d.extracted_date BETWEEN '2022-01-01' AND '2025-12-31'
```

### Example 6: Large PDFs Without Summaries

```
User input: format:pdf size:>5MB -has:summary

Parsed:
{
  formats: ["pdf"],
  sizeMin: 5242880,
  negations: { hasSummary: true }
}

SQL WHERE:
d.mime_type = 'application/pdf'
AND d.size_bytes > 5242880
AND d.llm_summary IS NULL
```

### Example 7: Fuzzy Entity Search

```
User input: company:Aple (typo)

Autocorrect/fuzzy match → "Apple"

Uses trigram similarity or Levenshtein distance to suggest correction.
```

---

## Faceted Search

Facets provide counts for filtering. They update dynamically based on current search/filters.

### Example Response

```json
{
  "facets": {
    "types": [
      { "name": "photo", "count": 234 },
      { "name": "document", "count": 89 },
      { "name": "receipt", "count": 45 },
      { "name": "screenshot", "count": 23 }
    ],
    "formats": [
      { "name": "jpg", "count": 198 },
      { "name": "png", "count": 67 },
      { "name": "pdf", "count": 89 },
      { "name": "txt", "count": 12 }
    ],
    "folders": [
      { "name": "/photos/vacation", "count": 156 },
      { "name": "/documents/tax", "count": 45 },
      { "name": "/receipts/2024", "count": 32 }
    ],
    "uploadPeriod": [
      { "name": "This week", "count": 12 },
      { "name": "This month", "count": 45 },
      { "name": "This year", "count": 234 },
      { "name": "Older", "count": 156 }
    ],
    "hasText": [
      { "name": "With text", "count": 178 },
      { "name": "Without text", "count": 213 }
    ],
    "tags": [
      { "name": "important", "count": 34 },
      { "name": "tax", "count": 28 },
      { "name": "work", "count": 19 }
    ],
    "entities": [
      { "name": "Apple Inc.", "count": 23 },
      { "name": "Amazon", "count": 18 },
      { "name": "John Smith", "count": 12 }
    ]
  }
}
```

### Facet Behavior

- **Primary facets** (types, formats, uploadPeriod) always shown
- **Secondary facets** (tags, entities) shown if data exists
- Clicking a facet adds/toggles the corresponding filter
- Facet counts update to reflect current filtered results

---

## Autocomplete / Suggestions

### Suggestion Types

| Type | Endpoint | Use Case |
|------|----------|----------|
| `filename` | `/api/search/suggest/filename?q=vac` | Filename autocomplete |
| `folder` | `/api/search/suggest/folder?q=/doc` | Folder path autocomplete |
| `tag` | `/api/search/suggest/tag?q=imp` | Tag autocomplete |
| `entity` | `/api/search/suggest/entity?q=App` | Company/person autocomplete |
| `category` | `/api/search/suggest/category?q=rec` | Category autocomplete |

### Filename Suggestions

```
GET /api/search/suggest/filename?q=vacation
Response: ["vacation-2024-beach.jpg", "vacation-hawaii-sunset.jpg", "vacation-budget.pdf"]
```

```typescript
async function suggestFilenames(prefix: string, userId: string): Promise<string[]> {
  const results = await db
    .selectFrom('documents')
    .select('original_filename')
    .distinct()
    .where('user_id', '=', userId)
    .where('original_filename', 'ilike', `${prefix}%`)
    .orderBy('created_at', 'desc')
    .limit(10)
    .execute();
  
  return results.map(r => r.original_filename);
}
```

### Folder Suggestions

```
GET /api/search/suggest/folder?q=/photos
Response: ["/photos/vacation", "/photos/family", "/photos/work"]
```

```typescript
async function suggestFolders(prefix: string, userId: string): Promise<string[]> {
  const results = await db
    .selectFrom('folders')
    .select('path')
    .distinct()
    .where('user_id', '=', userId)
    .where('path', 'ilike', `${prefix}%`)
    .orderBy('path', 'asc')
    .limit(10)
    .execute();
  
  return results.map(r => r.path);
}
```

### Entity Suggestions

```
GET /api/search/suggest/entity?q=App
Response: ["Apple Inc.", "Applied Materials", "Amazon"]
```

```typescript
import { sql } from 'kysely';

async function suggestEntities(prefix: string, userId: string): Promise<string[]> {
  // Search in OCR metadata companies
  const results = await db
    .selectFrom('ocr_results as ocr')
    .innerJoin('documents as d', 'd.id', 'ocr.document_id')
    .select(sql<string>`DISTINCT jsonb_array_elements_text(ocr.metadata->'companies')`.as('entity'))
    .where('d.user_id', '=', userId)
    .where(sql`jsonb_array_elements_text(ocr.metadata->'companies') ILIKE ${prefix + '%'}`)
    .limit(10)
    .execute();
  
  return results.map(r => r.entity);
}
```

### Recent Searches

Store user's recent searches for quick access (client-side or DB-backed):

```typescript
interface RecentSearch {
  query: string;
  timestamp: Date;
  resultCount: number;
}
```

### Quick Filters

Predefined shortcuts shown in search UI:

```typescript
const quickFilters = [
  { label: "Photos", query: "type:photo" },
  { label: "Documents", query: "type:document" },
  { label: "Recent", query: "uploaded:last-week" },
  { label: "Large files", query: "size:>10MB" },
  { label: "No text", query: "-has:text" },
];
```

---

## Highlighting and Snippets

Use PostgreSQL's `ts_headline` function via Kysely to generate context snippets:

```typescript
import { sql } from 'kysely';

function buildSearchWithSnippets(searchTerm: string) {
  const tsQuery = sql`plainto_tsquery('english', ${searchTerm})`;
  
  return db
    .selectFrom('documents as d')
    .innerJoin('ocr_results as ocr', 'ocr.document_id', 'd.id')
    .select([
      'd.id',
      'd.original_filename',
      sql<string>`ts_headline(
        'english',
        ocr.raw_text,
        ${tsQuery},
        'StartSel=<mark>, StopSel=</mark>, MaxWords=50, MinWords=25'
      )`.as('snippet'),
      sql<number>`ts_rank(ocr.text_vector, ${tsQuery})`.as('relevance'),
    ])
    .where(sql`ocr.text_vector @@ ${tsQuery}`)
    .orderBy('relevance', 'desc');
}
```

Result:

```
"...portfolio holdings include <mark>Apple</mark> Inc. (AAPL) with 150 shares valued at..."
```

### Snippet for filename matches

For files matching by filename (not content), show folder context instead:

```typescript
function getFilenameSnippet(doc: Document): string {
  return `${doc.folder_path}/${doc.original_filename}`;
}
```

---

## Performance Optimizations

### Indexes

Most indexes are created in the initial migration (Plan 02). Additional indexes for search:

```typescript
// In migration file
import { Kysely, sql } from 'kysely';

export async function up(db: Kysely<unknown>): Promise<void> {
  // Full-text search (already in Plan 02)
  await sql`CREATE INDEX idx_ocr_text_search ON ocr_results USING GIN(text_vector)`.execute(db);

  // Category and type filtering (already in Plan 02)
  await db.schema.createIndex('idx_documents_category').on('documents').column('document_category').execute();
  
  // Additional indexes for search filters
  await db.schema.createIndex('idx_documents_mime_type').on('documents').column('mime_type').execute();
  await db.schema.createIndex('idx_documents_created_at').on('documents').column('created_at').execute();
  await db.schema.createIndex('idx_documents_size').on('documents').column('size_bytes').execute();
  await db.schema.createIndex('idx_documents_has_text').on('documents').column('has_meaningful_text').execute();
  await db.schema.createIndex('idx_folders_path').on('folders').column('path').execute();

  // Trigram extension for fuzzy filename matching
  await sql`CREATE EXTENSION IF NOT EXISTS pg_trgm`.execute(db);
  await sql`CREATE INDEX idx_documents_filename_trgm ON documents USING GIN(original_filename gin_trgm_ops)`.execute(db);

  // JSONB index for entity search
  await sql`CREATE INDEX idx_ocr_metadata_companies ON ocr_results USING GIN((metadata->'companies'))`.execute(db);
}
```

### Query Caching

- Cache common queries (e.g., "all documents in folder X")
- Cache facet counts (invalidate on document add/delete)
- Invalidate on document updates

### Pagination

- Limit results to 50 per page
- Use cursor-based pagination for large result sets
- For very large result sets, use keyset pagination with `(created_at, id)`

---

## API Endpoints

### Main Search

```
GET /api/search?q=type:photo folder:vacation uploaded:2024

Response: {
  "total": 156,
  "results": [
    {
      "document_id": "abc-123",
      "filename": "beach-sunset.jpg",
      "folder_path": "/photos/vacation/2024",
      "uploaded_at": "2024-07-15T10:30:00Z",
      "category": "photo",
      "mime_type": "image/jpeg",
      "format": "jpg",
      "has_text": false,
      "thumbnail_url": "/api/thumbnails/abc-123/md",
      "blurhash": "LEHV6nWB2yk8pyo0adR*.7kCMdnj",
      "size_bytes": 2456789,
      "tags": ["vacation", "beach"]
    },
    ...
  ],
  "facets": {...},
  "query": {
    "types": ["photo"],
    "folders": ["/vacation"],
    "uploadedRange": { "start": "2024-01-01", "end": "2024-12-31" }
  },
  "timing_ms": 45
}
```

### Text Search with Snippets

```
GET /api/search?q=dividend+payment+company:Apple

Response: {
  "total": 12,
  "results": [
    {
      "document_id": "def-456",
      "filename": "apple-q3-2024.pdf",
      "snippet": "...quarterly <mark>dividend</mark> <mark>payment</mark> of $0.25 per share...",
      "relevance": 0.89,
      "has_text": true,
      ...
    }
  ]
}
```

### Facets Only

```
GET /api/search/facets?q=folder:vacation

Response: {
  "facets": {
    "types": [{"name": "photo", "count": 234}, ...],
    "formats": [{"name": "jpg", "count": 198}, ...],
    ...
  }
}
```

### Suggestions

```
GET /api/search/suggest/folder?q=/photos
Response: ["/photos/vacation", "/photos/family", "/photos/work"]

GET /api/search/suggest/entity?q=App
Response: ["Apple Inc.", "Applied Materials", "Amazon"]

GET /api/search/suggest/tag?q=imp
Response: ["important", "imported", "improvement"]
```

### Recent Searches

```
GET /api/search/recent
Response: [
  { "query": "type:photo vacation", "timestamp": "2024-01-15T10:30:00Z", "resultCount": 45 },
  { "query": "format:pdf tax", "timestamp": "2024-01-14T14:20:00Z", "resultCount": 12 }
]
```

---

## Advanced Features (Future)

### Semantic Search (pgvector)

- Generate embeddings for OCR text
- Store in `ocr_results.embedding` (vector column)
- Query: `ORDER BY embedding <-> query_embedding LIMIT 10`
- Allows: "Find documents similar to this one"

### Saved Searches

- User creates complex query
- Saves with name
- Can be re-run or set as alert

### Search Alerts

- User defines search query
- Notified when new documents match
- "Alert me when new Apple stock documents are added"

---

## Searching Files Without Text

Photos and other non-text files (`has_meaningful_text = false`) can still be searched via:

### Searchable Fields

| Field | Example | How it works |
|-------|---------|--------------|
| Filename | `vacation-beach-2024.jpg` | Text match against original_filename |
| Folder path | `/photos/vacation/hawaii` | Match against folder path |
| Category | `photo`, `screenshot` | Filter by document_category |
| Tags | `beach`, `family` | User-added or auto-generated tags |
| Upload date | `2024-07-15` | Filter by created_at |
| LLM description | "Beach sunset with palm trees" | If vision model was used (Plan 06) |

### Example Queries for Photos

```
type:photo                           # All photos
type:photo folder:vacation           # Photos in vacation folder
type:photo uploaded:2024             # Photos uploaded in 2024
type:photo tag:family                # Photos tagged "family"
beach type:photo                     # Photos with "beach" in filename or description
```

### Visual Search (Future)

For true content-based image search:
- Generate image embeddings using CLIP or similar
- Store in pgvector column
- Query: "Find photos similar to this one"
- Query: "Find photos of beaches" (text-to-image search)

---

## Error Handling

### Invalid Query Syntax

- Return helpful error: "Invalid date format, expected YYYY-MM-DD"
- Suggest corrections

### No Results

- Show suggestions: "Did you mean 'Apple' instead of 'Aple'?"
- Show recent searches
- Show popular searches

### Timeout

- If query takes >5s, cancel and suggest narrowing search

---

## Acceptance Criteria

**Core Search:**
- Search API endpoint works
- Simple text search finds results in filenames, OCR text, and summaries
- Full-text search returns relevant results with highlighted snippets

**Filters:**
- `type:` filter works (photo, document, receipt, screenshot)
- `format:` filter works (pdf, jpg, png, etc.)
- `uploaded:` filter works with dates and relative values (last-week)
- `date:` filter works for extracted dates
- `folder:` filter works with paths and partial matches
- `has:` filter works (text, summary, thumbnail)
- `size:` filter works with comparisons (>1MB)
- `tag:` filter works
- `entity:` / `company:` filter works
- Negation (`-has:text`) works

**Facets:**
- Facets are generated correctly
- Facet counts update based on current filters
- Primary facets (types, formats, uploadPeriod) always shown

**Suggestions:**
- Autocomplete works for filenames, folders, tags, entities
- Recent searches are tracked and returned

**Performance:**
- Performance is <100ms for typical queries
- Queries with multiple filters remain fast

**Edge Cases:**
- Search works for files without text (photos)
- Empty search returns recent files
- Invalid filter syntax returns helpful error

---

## Future Enhancements

- **Multi-language support**: Detect document language, use appropriate stemmer
- **Boolean operators**: Explicit AND, OR, NOT in text search
- **Proximity search**: "Apple" within 5 words of "stock"
- **Image similarity search**: Find visually similar photos (requires embeddings)
- **Semantic search**: "Find documents about money" matches "invoice", "payment", "budget"
- **Saved searches**: Save complex queries with names for quick access
- **Search alerts**: Notify when new documents match a saved search
- **Export search results**: CSV, JSON export of search results
- **Search analytics**: Track popular searches, failed searches
- **Natural language queries**: "Show me photos from last summer" → `type:photo uploaded:2023-06..2023-08`
